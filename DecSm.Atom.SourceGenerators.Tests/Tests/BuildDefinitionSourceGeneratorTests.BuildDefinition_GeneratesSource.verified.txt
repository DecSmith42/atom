// <auto-generated/>

#nullable enable

global using static TestNamespace.DefaultTestDefinition;

using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using DecSm.Atom.Build.Definition;
using DecSm.Atom.Params;
using DecSm.Atom.Paths;
using DecSm.Atom.Process;

namespace TestNamespace;

[JetBrains.Annotations.PublicAPI]
partial class DefaultTestDefinition : DecSm.Atom.Build.Definition.IBuildDefinition, DecSm.Atom.Hosting.IConfigureHost
{
    public DefaultTestDefinition(System.IServiceProvider services) : base(services) { }

    private ILogger Logger => Services.GetRequiredService<ILoggerFactory>().CreateLogger("TestNamespace.DefaultTestDefinition");

    private IAtomFileSystem FileSystem => GetService<IAtomFileSystem>();

    private IProcessRunner ProcessRunner => GetService<IProcessRunner>();

    private T GetService<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.Interfaces)] T>()
        where T : notnull =>
        typeof(T).GetInterface(nameof(IBuildDefinition)) != null
            ? (T)(IBuildDefinition)this
            : Services.GetRequiredService<T>();

    private IEnumerable<T> GetServices<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.Interfaces)] T>()
        where T : notnull =>
        typeof(T).GetInterface(nameof(IBuildDefinition)) != null
            ? [(T)(IBuildDefinition)this]
            : Services.GetServices<T>();

    [return: NotNullIfNotNull(nameof(defaultValue))]
    private T? GetParam<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] T>(
        Expression<Func<T?>> parameterExpression,
        T? defaultValue = default,
        Func<string?, T?>? converter = null) =>
            Services
                .GetRequiredService<IParamService>()
                .GetParam(parameterExpression, defaultValue, converter);

    #region Targets

    private System.Collections.Generic.IReadOnlyDictionary<string, DecSm.Atom.Build.Definition.Target>? _targetDefinitions;

    public override System.Collections.Generic.IReadOnlyDictionary<string, Target> TargetDefinitions => _targetDefinitions ??= new System.Collections.Generic.Dictionary<string, Target>
    {
        { nameof(DecSm.Atom.ISetupBuildInfo.SetupBuildInfo), ((DecSm.Atom.ISetupBuildInfo)this).SetupBuildInfo },
    };

    public static class WorkflowTargets
    {
        public static readonly DecSm.Atom.Workflows.Definition.WorkflowTargetDefinition SetupBuildInfo = new(nameof(DecSm.Atom.ISetupBuildInfo.SetupBuildInfo));
    }

    private static DecSm.Atom.Workflows.Definition.WorkflowTargetDefinition WorkflowTarget(string name) =>
        name switch
        {
            nameof(DecSm.Atom.ISetupBuildInfo.SetupBuildInfo) => WorkflowTargets.SetupBuildInfo,
            _ => throw new System.ArgumentException($"Target with name '{name}' is not defined in the build definition.", nameof(name))
        };

    #endregion Targets

    #region Params

    private readonly System.Collections.Generic.IReadOnlyDictionary<string, DecSm.Atom.Params.ParamDefinition> _paramDefinitions = new System.Collections.Generic.Dictionary<string, DecSm.Atom.Params.ParamDefinition>()
    {
        {
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildName), new(nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildName))
            {
                ArgName = "build-name",
                Description = "The name of the build.",
                Sources = (DecSm.Atom.Params.ParamSource)47,
                IsSecret = false,
                ChainedParams = [],
            }
        },
        {
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildId), new(nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildId))
            {
                ArgName = "build-id",
                Description = "The unique identifier for the build run.",
                Sources = (DecSm.Atom.Params.ParamSource)47,
                IsSecret = false,
                ChainedParams = [],
            }
        },
        {
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildVersion), new(nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildVersion))
            {
                ArgName = "build-version",
                Description = "The semantic version of the build.",
                Sources = (DecSm.Atom.Params.ParamSource)47,
                IsSecret = false,
                ChainedParams = [],
            }
        },
        {
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildTimestamp), new(nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildTimestamp))
            {
                ArgName = "build-timestamp",
                Description = "The build timestamp in Unix epoch seconds.",
                Sources = (DecSm.Atom.Params.ParamSource)47,
                IsSecret = false,
                ChainedParams = [],
            }
        },
        {
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildSlice), new(nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildSlice))
            {
                ArgName = "build-slice",
                Description = "An identifier for a build variation, used in matrix jobs.",
                Sources = (DecSm.Atom.Params.ParamSource)47,
                IsSecret = false,
                ChainedParams = [],
            }
        },
    };

    public override System.Collections.Generic.IReadOnlyDictionary<string, ParamDefinition> ParamDefinitions => _paramDefinitions;

    public sealed class ParamsData(DecSm.Atom.Build.Definition.IBuildDefinition buildDefinition)
    {
        public ParamDefinition BuildName => buildDefinition.ParamDefinitions[nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildName)];
        public ParamDefinition BuildId => buildDefinition.ParamDefinitions[nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildId)];
        public ParamDefinition BuildVersion => buildDefinition.ParamDefinitions[nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildVersion)];
        public ParamDefinition BuildTimestamp => buildDefinition.ParamDefinitions[nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildTimestamp)];
        public ParamDefinition BuildSlice => buildDefinition.ParamDefinitions[nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildSlice)];
    }

    private ParamsData? _params;

    public ParamsData WorkflowParams => _params ??= new(this);

    public override object? AccessParam(string paramName) =>
        paramName switch
        {
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildName) => ((DecSm.Atom.BuildInfo.IBuildInfo)this).BuildName,
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildId) => ((DecSm.Atom.BuildInfo.IBuildInfo)this).BuildId,
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildVersion) => ((DecSm.Atom.BuildInfo.IBuildInfo)this).BuildVersion,
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildTimestamp) => ((DecSm.Atom.BuildInfo.IBuildInfo)this).BuildTimestamp,
            nameof(DecSm.Atom.BuildInfo.IBuildInfo.BuildSlice) => ((DecSm.Atom.BuildInfo.IBuildInfo)this).BuildSlice,
            _ => throw new System.ArgumentException($"Param with name '{paramName}' is not defined in the build definition.", nameof(paramName))
        };

    #endregion Params

    #region Host

    public void ConfigureBuildHost(Microsoft.Extensions.Hosting.IHost builder) { }

    public void ConfigureBuildHostBuilder(Microsoft.Extensions.Hosting.IHostApplicationBuilder builder)
    {
        Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton<DecSm.Atom.ISetupBuildInfo>(builder.Services, static p => (DecSm.Atom.ISetupBuildInfo)p.GetRequiredService<DecSm.Atom.Build.Definition.IBuildDefinition>());
        Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton<DecSm.Atom.BuildInfo.IBuildInfo>(builder.Services, static p => (DecSm.Atom.BuildInfo.IBuildInfo)p.GetRequiredService<DecSm.Atom.Build.Definition.IBuildDefinition>());
        Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton<DecSm.Atom.Variables.IVariablesHelper>(builder.Services, static p => (DecSm.Atom.Variables.IVariablesHelper)p.GetRequiredService<DecSm.Atom.Build.Definition.IBuildDefinition>());
        Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton<DecSm.Atom.Reports.IReportsHelper>(builder.Services, static p => (DecSm.Atom.Reports.IReportsHelper)p.GetRequiredService<DecSm.Atom.Build.Definition.IBuildDefinition>());
        DecSm.Atom.Secrets.IDotnetUserSecrets.ConfigureBuilder(builder);
    }

    #endregion Host
}
