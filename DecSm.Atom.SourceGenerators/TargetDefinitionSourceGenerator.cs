using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using DeclarationResult = (Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax Declaration, bool HasAttribute);

namespace DecSm.Atom.SourceGenerators;

[Generator]
public class TargetDefinitionSourceGenerator : IIncrementalGenerator
{
    // ReSharper disable InconsistentNaming

    private const string TargetDefinitionAttributeFull = "DecSm.Atom.Build.Definition.TargetDefinitionAttribute";
    private const string IBuildDefinitionFull = "DecSm.Atom.Build.Definition.IBuildDefinition";
    private const string GetService = "GetService";

    // ReSharper restore InconsistentNaming

    public void Initialize(IncrementalGeneratorInitializationContext context) =>
        context.RegisterSourceOutput(context.CompilationProvider.Combine(context
                .SyntaxProvider
                .CreateSyntaxProvider(static (syntaxNode, unknown) => syntaxNode is InterfaceDeclarationSyntax,
                    static (context, _) => GetInterfaceDeclaration(context))
                .Where(static declarationResult => declarationResult.HasAttribute)
                .Select(static (declarationResult, _) => declarationResult.Declaration)
                .Collect()),
            GenerateCode);

    private static DeclarationResult GetInterfaceDeclaration(GeneratorSyntaxContext context)
    {
        var interfaceDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in interfaceDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attributeSyntax);

            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeName == TargetDefinitionAttributeFull)
                return (interfaceDeclarationSyntax, true);
        }

        return (interfaceDeclarationSyntax, false);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        (Compilation Compilation, ImmutableArray<InterfaceDeclarationSyntax> ClassDeclarations) compilationWithClassDeclarations)
    {
        foreach (var interfaceDeclarationSyntax in compilationWithClassDeclarations.ClassDeclarations)
            if (compilationWithClassDeclarations
                    .Compilation
                    .GetSemanticModel(interfaceDeclarationSyntax.SyntaxTree)
                    .GetDeclaredSymbol(interfaceDeclarationSyntax) is INamedTypeSymbol classSymbol)
                GeneratePartial(context, classSymbol, interfaceDeclarationSyntax);
    }

    private static void GeneratePartial(
        SourceProductionContext context,
        INamedTypeSymbol interfaceSymbol,
        InterfaceDeclarationSyntax interfaceDeclarationSyntax)
    {
        var @namespace = interfaceSymbol.ContainingNamespace.ToDisplayString();

        var namespaceLine = @namespace is "<global namespace>"
            ? string.Empty
            : $"namespace {@namespace};";

        var @interface = interfaceDeclarationSyntax.Identifier.Text;

        // Build up the source code
        var code = $$"""
                     // <auto-generated/>

                     #nullable enable

                     {{namespaceLine}}

                     [JetBrains.Annotations.PublicAPI]
                     partial interface {{@interface}} : {{IBuildDefinitionFull}}
                     {
                         private Microsoft.Extensions.Logging.ILogger<{{@interface}}> Logger => {{GetService}}<Microsoft.Extensions.Logging.ILogger<{{@interface}}>>();
                         private System.IO.Abstractions.IFileSystem FileSystem => {{GetService}}<System.IO.Abstractions.IFileSystem>();
                     }

                     """;

        // Add the source code to the compilation.
        context.AddSource($"{@interface}.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}