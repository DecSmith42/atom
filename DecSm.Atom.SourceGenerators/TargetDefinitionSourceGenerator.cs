using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DecSm.Atom.SourceGenerators;

[Generator]
public class TargetDefinitionSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter classes annotated with the [TargetDefinition] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context
            .SyntaxProvider
            .CreateSyntaxProvider((s, _) => s is InterfaceDeclarationSyntax, (ctx, _) => GetInterfaceDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);
        
        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }
    
    private static (InterfaceDeclarationSyntax, bool reportAttributeFound) GetInterfaceDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;
        
        // Go through all attributes of the class.
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax)
                    .Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it
            
            var attributeName = attributeSymbol.ContainingType.ToDisplayString();
            
            // Check the full name of the [Report] attribute.
            if (attributeName == "DecSm.Atom.Build.Definition.TargetDefinitionAttribute")
                return (classDeclarationSyntax, true);
        }
        
        return (classDeclarationSyntax, false);
    }
    
    private void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<InterfaceDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            
            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol interfaceSymbol)
                continue;
            
            var namespaceLine = interfaceSymbol.ContainingNamespace.ToDisplayString() is "<global namespace>"
                ? string.Empty
                : $"namespace {interfaceSymbol.ContainingNamespace.ToDisplayString()};";
            
            var interfaceName = classDeclarationSyntax.Identifier.Text;
            
            // Build up the source code
            var code = $$"""
                         // <auto-generated/>
                         
                         using System;
                         using System.Collections.Generic;
                         using DecSm.Atom;
                         using DecSm.Atom.Build.Definition;
                         using JetBrains.Annotations;
                         using Microsoft.Extensions.DependencyInjection;
                         using Microsoft.Extensions.Logging;
                         
                         {{namespaceLine}}
                         
                         [PublicAPI]
                         partial interface {{interfaceName}} : IBuildDefinition
                         {
                             private ILogger<{{interfaceName}}> Logger => Services.GetRequiredService<ILogger<{{interfaceName}}>>();
                             private System.IO.Abstractions.IFileSystem FileSystem => Services.GetRequiredService<System.IO.Abstractions.IFileSystem>();
                         }
                         
                         """;
            
            // Add the source code to the compilation.
            context.AddSource($"{interfaceName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}