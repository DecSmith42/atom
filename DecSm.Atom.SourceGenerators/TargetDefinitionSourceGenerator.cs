using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using DeclarationResult = (Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax Declaration, bool HasAttribute);

// Resharper disable ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator - perf

namespace DecSm.Atom.SourceGenerators;

[Generator]
public class TargetDefinitionSourceGenerator : IIncrementalGenerator
{
    private const string TargetDefinitionAttributeFull = "DecSm.Atom.Build.Definition.TargetDefinitionAttribute";
    private const string IBuildDefinitionFull = "DecSm.Atom.Build.Definition.IBuildDefinition";
    private const string IBuildAccessorFull = "DecSm.Atom.Build.IBuildAccessor";

    public void Initialize(IncrementalGeneratorInitializationContext context) =>
        context.RegisterSourceOutput(context.CompilationProvider.Combine(context
                .SyntaxProvider
                .CreateSyntaxProvider(static (syntaxNode, _) => syntaxNode is InterfaceDeclarationSyntax,
                    static (context, _) => GetInterfaceDeclaration(context))
                .Where(static declarationResult => declarationResult.HasAttribute)
                .Select(static (declarationResult, _) => declarationResult.Declaration)
                .Collect()),
            GenerateCode);

    private static DeclarationResult GetInterfaceDeclaration(GeneratorSyntaxContext context)
    {
        var interfaceDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in interfaceDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attributeSyntax);

            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeName == TargetDefinitionAttributeFull)
                return (interfaceDeclarationSyntax, true);
        }

        return (interfaceDeclarationSyntax, false);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        (Compilation Compilation, ImmutableArray<InterfaceDeclarationSyntax> ClassDeclarations) compilationWithClassDeclarations)
    {
        foreach (var interfaceDeclarationSyntax in compilationWithClassDeclarations.ClassDeclarations)
            if (compilationWithClassDeclarations
                    .Compilation
                    .GetSemanticModel(interfaceDeclarationSyntax.SyntaxTree)
                    .GetDeclaredSymbol(interfaceDeclarationSyntax) is INamedTypeSymbol classSymbol)
                GeneratePartial(context, classSymbol, interfaceDeclarationSyntax);
    }

    private static void GeneratePartial(
        SourceProductionContext context,
        INamedTypeSymbol interfaceSymbol,
        InterfaceDeclarationSyntax interfaceDeclarationSyntax)
    {
        var @namespace = interfaceSymbol.ContainingNamespace.ToDisplayString();

        var namespaceLine = @namespace is "<global namespace>"
            ? string.Empty
            : $"namespace {@namespace};";

        var @interface = interfaceDeclarationSyntax.Identifier.Text;

        // Build up the source code
        var code = $"""
                    // <auto-generated/>

                    #nullable enable

                    {namespaceLine}

                    [JetBrains.Annotations.PublicAPI]
                    partial interface {@interface} : {IBuildAccessorFull};

                    """;

        // Add the source code to the compilation.
        context.AddSource($"{@interface}.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}
