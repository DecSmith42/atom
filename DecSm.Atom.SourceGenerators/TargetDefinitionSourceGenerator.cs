using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DecSm.Atom.SourceGenerators;

[Generator]
public class TargetDefinitionSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "DecSm.AtomGen";
    private const string AttributeName = "TargetDefinitionAttribute";

    private const string AttributeSourceCode =
        $$"""
          // <auto-generated/>

          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Interface)]
              public class {{AttributeName}} : System.Attribute
              {
              }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "TargetDefinitionAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is InterfaceDeclarationSyntax,
                (ctx, _) => GetInterfaceDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private static (InterfaceDeclarationSyntax, bool reportAttributeFound) GetInterfaceDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (InterfaceDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [Report] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
                return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<InterfaceDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceLine = classSymbol.ContainingNamespace.ToDisplayString() is "<global namespace>"
                ? string.Empty
                : $"namespace {classSymbol.ContainingNamespace.ToDisplayString()};";

            var interfaceName = classDeclarationSyntax.Identifier.Text;

            // Build up the source code
            var code = $$"""
                         // <auto-generated/>

                         using System;
                         using System.Collections.Generic;
                         using DecSm.Atom;
                         using JetBrains.Annotations;
                         using Microsoft.Extensions.DependencyInjection;
                         
                         {{namespaceLine}}
                         
                         [PublicAPI]
                         partial interface {{interfaceName}} : IAtomBuildDefinition
                         {
                             private ILogger<{{interfaceName}}> Logger => Services.GetRequiredService<ILogger<{{interfaceName}}>>();
                         }

                         """;

            // Add the source code to the compilation.
            context.AddSource($"{interfaceName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}