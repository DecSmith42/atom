using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DecSm.Atom.SourceGenerators;

[Generator]
public class BuildDefinitionSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "DecSm.AtomGen";
    private const string AttributeName = "BuildDefinitionAttribute";

    private const string AttributeSourceCode =
        $$"""
          // <auto-generated/>

          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Class)]
              public class {{AttributeName}} : System.Attribute
              {
              }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "BuildDefinitionAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private static (ClassDeclarationSyntax, bool reportAttributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [Report] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
                return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceLine = classSymbol.ContainingNamespace.ToDisplayString() is "<global namespace>"
                ? string.Empty
                : $"namespace {classSymbol.ContainingNamespace.ToDisplayString()};";

            var className = classDeclarationSyntax.Identifier.Text;

            // Get all defined targets (property that returns Target) in all inherited interfaces
            var interfaceTargets = classSymbol.AllInterfaces
                .SelectMany(i => i.GetMembers().OfType<IPropertySymbol>().Select(x => (Interface: i, Property: x)))
                .Where(p => p.Property.Type.Name == "Target")
                .Select(p => (p.Interface, p.Property))
                .ToList();

            // Generate the source code for the Targets property.
            var targetDefinitionsPropertyBody = interfaceTargets.Select(p =>
                $$"""        { "{{p.Property.Name}}", (({{p.Interface}})this).{{p.Property.Name}} },""");

            // Get all defined Params (Property with ParamAttribute) in all inherited interfaces,
            // along with the ParamAttribute.Name value
            var interfaceParams = classSymbol.AllInterfaces
                .SelectMany(i => i.GetMembers().OfType<IPropertySymbol>().Select(x => (Interface: i, Property: x)))
                .Where(p => p.Property.GetAttributes().Any(a => a.AttributeClass?.Name == "ParamAttribute"))
                .Select(p => (p.Interface, p.Property, p.Property.GetAttributes().First(a => a.AttributeClass?.Name == "ParamAttribute")))
                .ToList();

            // For each param, we want to get the attribute so we can pull out the info
            var paramDefinitionsPropertyBody = interfaceParams
                .Select(x =>
                {
                    var interfaceName = $"{x.Interface.ContainingNamespace.ToDisplayString()}.{x.Interface.Name}";

                    return new
                    {
                        x.Property.Name,
                        Interface = $"typeof({interfaceName})",
                        Attribute = $"typeof({interfaceName}).GetProperty(\"{x.Property.Name}\", BindingFlags.Instance | BindingFlags.Public)!.GetCustomAttribute<ParamAttribute>()!"
                    };
                })
                .Select(p =>
                    $$"""        { "{{p.Name}}", new("{{p.Name}}", {{p.Interface}}, {{p.Attribute}}) },""");

            // Build up the source code
            var code = $$"""
                         // <auto-generated/>

                         #nullable enable

                         using System;
                         using System.Collections.Generic;
                         using System.Reflection;
                         using DecSm.Atom;
                         using DecSm.Atom.Params;
                         using JetBrains.Annotations;

                         {{namespaceLine}}

                         [PublicAPI]
                         partial class {{className}} : AtomBuildDefinition
                         {
                             public {{className}}(IServiceProvider services) : base(services) { }
                             
                             private Dictionary<string, Target>? _targetDefinitions;
                             private Dictionary<string, ParamDefinition>? _paramDefinitions;
                         
                             public override Dictionary<string, Target> TargetDefinitions => _targetDefinitions ??= new Dictionary<string, Target>
                             {
                         {{string.Join("\n", targetDefinitionsPropertyBody)}}
                             };
                             
                             public override Dictionary<string, ParamDefinition> ParamDefinitions => _paramDefinitions ??= new Dictionary<string, ParamDefinition>
                             {
                         {{string.Join("\n", paramDefinitionsPropertyBody)}}
                             };
                         }

                         """;

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}