using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DecSm.Atom.SourceGenerators;

[Generator]
public class BuildDefinitionSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "DecSm.AtomGen";
    private const string AttributeName = "BuildDefinitionAttribute";
    
    private const string AttributeSourceCode = $$"""
                                                 // <auto-generated/>
                                                 
                                                 namespace {{Namespace}}
                                                 {
                                                     [System.AttributeUsage(System.AttributeTargets.Class)]
                                                     public class {{AttributeName}} : System.Attribute
                                                     {
                                                     }
                                                 }
                                                 """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "BuildDefinitionAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));
        
        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context
            .SyntaxProvider
            .CreateSyntaxProvider((s, _) => s is ClassDeclarationSyntax, (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);
        
        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }
    
    private static (ClassDeclarationSyntax, bool reportAttributeFound) GetClassDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        
        // Go through all attributes of the class.
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax)
                    .Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it
            
            var attributeName = attributeSymbol.ContainingType.ToDisplayString();
            
            // Check the full name of the [Report] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
                return (classDeclarationSyntax, true);
        }
        
        return (classDeclarationSyntax, false);
    }
    
    private void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            
            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;
            
            var namespaceLine = classSymbol.ContainingNamespace.ToDisplayString() is "<global namespace>"
                ? string.Empty
                : $"namespace {classSymbol.ContainingNamespace.ToDisplayString()};";
            
            var className = classDeclarationSyntax.Identifier.Text;
            
            // Get all defined targets (property that returns Target) in all inherited interfaces
            var interfaceTargets = classSymbol
                .AllInterfaces
                .SelectMany(i => i
                    .GetMembers()
                    .OfType<IPropertySymbol>()
                    .Select(x => (Interface: i, Property: x)))
                .Where(p => p.Property.Type.Name == "Target")
                .Select(p => (p.Interface, p.Property))
                .ToList();
            
            // Generate a static accessor for each target
            var targetsPropertiesBodies = interfaceTargets.Select(p =>
                $"        public static string {p.Property.Name} = nameof({p.Interface}.{p.Property.Name});");
            
            // Generate a static accessor for each CommandDefinition
            var commandDefsPropertyBodies = interfaceTargets.Select(p =>
                $"        public static CommandDefinition {p.Property.Name} = new(nameof({p.Interface}.{p.Property.Name}));");
            
            // Generate the source code for the Targets property.
            var targetDefinitionsPropertyBody = interfaceTargets.Select(p =>
                $$"""        { "{{p.Property.Name}}", (({{p.Interface}})this).{{p.Property.Name}} },""");
            
            // Get all defined Params (Property with ParamAttribute) in all inherited interfaces,
            // along with the ParamAttribute.Name value
            var interfaceParams = classSymbol
                .AllInterfaces
                .SelectMany(i => i
                    .GetMembers()
                    .OfType<IPropertySymbol>()
                    .Select(x => (Interface: i, Property: x)))
                .Where(p => p
                    .Property
                    .GetAttributes()
                    .Any(a => a.AttributeClass?.Name == "ParamAttribute"))
                .Select(p => (p.Interface, p.Property, p
                    .Property
                    .GetAttributes()
                    .First(a => a.AttributeClass?.Name == "ParamAttribute")))
                .ToList();
            
            // Generate a static accessor for each param
            var paramsPropertiesBodies = interfaceParams.Select(p =>
                $"        public static string {p.Property.Name} = nameof({p.Interface}.{p.Property.Name});");
            
            var interfaceSecretParams = classSymbol
                .AllInterfaces
                .SelectMany(i => i
                    .GetMembers()
                    .OfType<IPropertySymbol>()
                    .Select(x => (Interface: i, Property: x)))
                .Where(p => p
                    .Property
                    .GetAttributes()
                    .Any(a => a.AttributeClass?.Name == "SecretParamAttribute"))
                .Select(p => (p.Interface, p.Property, p
                    .Property
                    .GetAttributes()
                    .First(a => a.AttributeClass?.Name == "SecretParamAttribute")))
                .ToList();
            
            // Generate a static accessor for each secret param
            var secretParamsPropertiesBodies = interfaceSecretParams.Select(p =>
                $"        public static string {p.Property.Name} = nameof({p.Interface}.{p.Property.Name});");
            
            // For each param, we want to get the attribute so we can pull out the info
            var paramDefinitionsPropertyBody = interfaceParams
                .Select(x =>
                {
                    var interfaceName = $"{x.Interface.ContainingNamespace.ToDisplayString()}.{x.Interface.Name}";
                    
                    return new
                    {
                        x.Property.Name,
                        Interface = $"typeof({interfaceName})",
                        Attribute =
                            $"typeof({interfaceName}).GetProperty(\"{x.Property.Name}\", BindingFlags.Instance | BindingFlags.Public)!.GetCustomAttribute<ParamAttribute>()!",
                    };
                })
                .Select(p => $$"""        { "{{p.Name}}", new("{{p.Name}}", {{p.Interface}}, {{p.Attribute}}) },""");
            
            var secretParamDefinitionsPropertyBody = interfaceSecretParams
                .Select(x =>
                {
                    var interfaceName = $"{x.Interface.ContainingNamespace.ToDisplayString()}.{x.Interface.Name}";
                    
                    return new
                    {
                        x.Property.Name,
                        Interface = $"typeof({interfaceName})",
                        Attribute =
                            $"typeof({interfaceName}).GetProperty(\"{x.Property.Name}\", BindingFlags.Instance | BindingFlags.Public)!.GetCustomAttribute<SecretParamAttribute>()!",
                    };
                })
                .Select(p => $$"""        { "{{p.Name}}", new("{{p.Name}}", {{p.Interface}}, {{p.Attribute}}) },""");
            
            // Build up the source code
            var code = $$"""
                         // <auto-generated/>
                         
                         #nullable enable
                         
                         using System;
                         using System.Collections.Generic;
                         using System.Reflection;
                         using DecSm.Atom;
                         using DecSm.Atom.Params;
                         using JetBrains.Annotations;
                         
                         {{namespaceLine}}
                         
                         [PublicAPI]
                         partial class {{className}} : AtomBuildDefinition
                         {
                             public {{className}}(IServiceProvider services) : base(services) { }
                             
                             private Dictionary<string, Target>? _targetDefinitions;
                             private Dictionary<string, ParamDefinition>? _paramDefinitions;
                         
                             public override Dictionary<string, Target> TargetDefinitions => _targetDefinitions ??= new Dictionary<string, Target>
                             {
                         {{string.Join("\n", targetDefinitionsPropertyBody)}}
                             };
                             
                             public override Dictionary<string, ParamDefinition> ParamDefinitions => _paramDefinitions ??= new Dictionary<string, ParamDefinition>
                             {
                         {{string.Join("\n", paramDefinitionsPropertyBody)}}
                         {{string.Join("\n", secretParamDefinitionsPropertyBody)}}
                             };
                             
                             public static class Targets
                             {
                         {{string.Join("\n\n", targetsPropertiesBodies)}}
                             }
                             
                             public static class Commands
                             {
                         {{string.Join("\n\n", commandDefsPropertyBodies)}}
                             }
                             
                             public static class Params
                             {
                         {{string.Join("\n\n", paramsPropertiesBodies)}}
                             }
                             
                             public static class Secrets
                             {
                         {{string.Join("\n\n", secretParamsPropertiesBodies)}}
                             }
                         }
                         
                         """;
            
            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}